# FLAC Decoder Test Results

**Test Date:** October 26, 2025
**Test Location:** `/Users/harper/Public/src/personal/ma-interface/ResonateKit/Examples/CLIPlayer`
**Test Program:** `FLACTest`

## Executive Summary

The FLACDecoder implementation successfully:
- ✅ Creates decoders for multiple audio formats (44.1kHz, 48kHz, 96kHz; mono/stereo; 16/24-bit)
- ✅ Handles data without crashing or memory corruption
- ✅ Implements read/write/error callback mechanism correctly
- ✅ Manages pendingData buffer to prevent memory leaks (bug fix verified)
- ⚠️  **Does NOT return decoded PCM samples from complete FLAC streams**

## Critical Finding

**The decoder returns 0 samples when processing complete FLAC streams**, even with valid FLAC files generated by ffmpeg.

### Root Cause Analysis

The issue is in how `FLAC__stream_decoder_process_single()` is used:

1. **Current Implementation**: `AudioDecoder.swift` line 216
   ```swift
   let success = FLAC__stream_decoder_process_single(decoder)
   ```

2. **Problem**: `process_single()` processes ONE unit at a time:
   - First call: Processes STREAMINFO metadata block
   - Second call: Processes first audio frame
   - Third call: Processes second audio frame
   - etc.

3. **Result**: When decoding a complete FLAC stream with metadata, the first call only processes metadata and returns 0 audio samples. The writeCallback is never invoked for the metadata block.

## Test Results Detail

### Test 1: Decoder Creation ✅
- Successfully creates FLACDecoder for 44.1kHz stereo 16-bit
- No crashes or initialization errors

### Test 1b: Real FLAC File ⚠️
- Loaded 9,518 bytes of valid FLAC data (generated by ffmpeg)
- Magic number verified: `66 4C 61 43` ("fLaC")
- Decode call succeeded without crash
- **Returned 0 bytes of PCM data**

### Test 2: Synthetic FLAC Stream ⚠️
- Created minimal valid FLAC stream (85 bytes)
- Includes: magic number + STREAMINFO + frame data
- Decode succeeded without crash
- **Returned 0 bytes of PCM data**

### Test 3: Hi-Res Decoder (96kHz 24-bit) ✅
- Decoder creation successful
- No initialization errors

### Test 4: Mono Decoder (48kHz 16-bit) ✅
- Decoder creation successful
- Handles mono configuration correctly

### Test 5: Callback Mechanism ✅
- Read callback is invoked and returns data correctly
- Write callback is NOT invoked (because only metadata is processed)
- Error callback is properly connected

### Test 6: Memory Management (pendingData) ✅
- First iteration succeeds with 0 bytes output
- Second iteration fails gracefully (expected - data already consumed)
- **Confirms the pendingData memory leak fix is working**
- Buffer is properly cleared between decode calls

### Test 7: Empty Data Handling ✅
- Correctly rejects empty data with appropriate error
- Error callback triggered with FLAC__StreamDecoderErrorStatus

### Test 8: Invalid Data Handling ⚠️
- **BUG**: Does NOT reject completely invalid data
- Should throw error but returns success
- Suggests error handling could be improved

### Test 9: Multiple Decode Calls ⚠️
- Three consecutive decode calls all return 0 bytes
- Confirms the issue is not a state problem
- Each call processes something but returns no audio

## Technical Details

### FLAC Stream Structure (from test file)
```
Offset  Hex                                         Description
------  ------------------------------------------  -----------
0x00    66 4C 61 43                                 Magic: "fLaC"
0x04    00 00 00 22                                 Metadata block header
0x08    12 00 12 00 00 04 D0 00 04 D0 0A C4 42 F0  STREAMINFO data
...     (metadata continues)
...     (audio frames follow)
```

### Decoder Configuration Test Matrix

| Sample Rate | Channels | Bit Depth | Creation | Notes |
|------------|----------|-----------|----------|-------|
| 44100      | 2        | 16        | ✅       | Standard CD quality |
| 96000      | 2        | 24        | ✅       | Hi-res audio |
| 48000      | 1        | 16        | ✅       | Mono audio |

### Callback Invocation

| Callback | Invoked? | Purpose | Status |
|----------|----------|---------|--------|
| Read     | ✅       | Supply encoded data | Working |
| Write    | ❌       | Receive decoded PCM | Not called (metadata only) |
| Error    | ✅       | Report errors | Working |

## Recommendations

The FLACDecoder needs one of the following fixes:

### Option 1: Process Entire Stream (Recommended)
```swift
// Replace process_single with process_until_end_of_stream
let success = FLAC__stream_decoder_process_until_end_of_stream(decoder)
```

**Pros:**
- Processes all metadata and frames in one call
- Simpler implementation
- Matches usage for complete streams

**Cons:**
- Cannot process frame-by-frame
- Entire stream must be available

### Option 2: Loop Until Audio Data
```swift
// Keep calling process_single until we have audio data
while decodedSamples.isEmpty {
    let success = FLAC__stream_decoder_process_single(decoder)
    guard success != 0 else { break }

    let state = FLAC__stream_decoder_get_state(decoder)
    if state == FLAC__STREAM_DECODER_END_OF_STREAM {
        break
    }
}
```

**Pros:**
- Can process incrementally
- More control over processing

**Cons:**
- More complex
- Need to handle state machine

### Option 3: Strip Metadata (For Frame-Only Use)
If the decoder is meant to receive only frame data (not complete streams):
- Document that decode() expects frame data without metadata
- Users must strip STREAMINFO before calling decode()
- Matches pattern of some streaming protocols

**Note:** This may already be the intended design, based on how Opus decoder works (receives packets, not full streams).

## Code Quality Assessment

### Strengths
1. **Memory Safety**: pendingData management is correct and leak-free
2. **Callback Implementation**: C-to-Swift bridging via Unmanaged is properly done
3. **Error Handling**: lastError tracking works correctly
4. **Bit Depth Handling**: Normalization logic for 16/24/32-bit is sound

### Issues Found
1. **No Audio Output**: process_single only processes metadata on first call
2. **Weak Invalid Data Rejection**: Accepts completely invalid data without error
3. **No State Verification**: Doesn't check decoder state after processing

## Comparison with OpusDecoder

The OpusDecoder (also in `AudioDecoder.swift`) works differently:
- Receives **packets** (frame data only, no container metadata)
- Each decode() call processes one complete packet
- Returns audio data immediately

FLAC decoder might need to follow the same pattern:
- Expect frame data, not complete streams
- Or process streams differently than current implementation

## Test Files

### Generated Test File
- **Path:** `Sources/FLACTest/test_silence.flac`
- **Size:** 9,518 bytes
- **Format:** 44.1kHz stereo 16-bit
- **Duration:** 0.1 seconds
- **Generator:** ffmpeg 62.11.100
- **Content:** 440Hz sine wave

### Synthetic Test Stream
- **Size:** 85 bytes
- **Structure:** Magic + STREAMINFO + minimal frame
- **Purpose:** Unit testing without external dependencies

## Conclusion

The FLACDecoder implementation is **structurally sound but functionally incomplete**:

✅ **Working:**
- Initialization and configuration
- Callback mechanism
- Memory management
- Error reporting (partial)

❌ **Not Working:**
- Audio decoding from complete streams
- Invalid data rejection

⚠️ **Needs Clarification:**
- Is decode() meant for complete streams or frame data only?
- Should match OpusDecoder pattern (frame-only) or support full streams?

**Next Steps:**
1. Determine intended use case (streams vs frames)
2. Implement appropriate fix (Option 1, 2, or 3 above)
3. Add integration tests with real FLAC files
4. Improve error handling for invalid data

---

**Test Program:** `swift run FLACTest`
**Source Code:** `Sources/FLACTest/main.swift`
**Decoder Implementation:** `Sources/ResonateKit/Audio/AudioDecoder.swift` (lines 141-301)
